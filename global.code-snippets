{
  "log": {
    "prefix": "ll",
    "body": [
      "console.log(`$1 ==> `, $1);"
    ],
  },
  "provider": {
    "prefix": "ss-provider",
    "body": [
      "import { Injectable } from '@nestjs/common';",
      "",
      "@Injectable()",
      "export class $1Provider {",
      "  public constructor() {}",
      "}",
      "",
    ],
  },
  "service": {
    "prefix": "ss-service",
    "body": [
      "import { Injectable } from '@nestjs/common';",
      "",
      "@Injectable()",
      "export class $1Service {",
      "  public constructor() {}",
      "}",
      "",
    ],
  },
  "repository": {
    "prefix": "ss-repository",
    "body": [
      "import { Injectable } from '@nestjs/common';",
      "",
      "@Injectable()",
      "export class $1Repository {",
      "  public constructor(",
      "    @InjectModel($2.name)",
      "    private readonly model: Model<$2>,",
      "  ) {}",
      "}",
      "",
    ],
  },
  "event-controller": {
    "prefix": "ss-event-controller",
    "body": [
      "import { EventController, EventRoute } from '@flip/broker';",
      "import { Context, IContext, Payload } from '@flip/intelligence';",
      "",
      "@EventController()",
      "export class $1Controller {",
      "  public constructor() {}",
      "}",
      "",
      "@EventRoute($2)",
      "public async (@Payload(): dto: $3, @Context() context: IContext): Promise<void> {",
      "}"
    ],
  },
  "event-route": {
    "prefix": "ss-event-route",
    "body": [
      "@EventRoute($1)",
      "public async (@Payload(): dto: $2, @Context() context: IContext): Promise<void> {",
      "}"
    ],
  },
  "integration-test": {
    "prefix": "ss-test-integration",
    "body": [
      "import { IContext, LoggerService } from '@flip/intelligence';",
      "import {",
      "  getConnectionToken,",
      "  getModelToken,",
      "  MongooseModule,",
      "} from '@nestjs/mongoose';",
      "import { Test, TestingModule } from '@nestjs/testing';",
      "import { MongoMemoryServer } from 'mongodb-memory-server';",
      "import { Connection, Model } from 'mongoose';",
      "import { instance, mock, reset } from 'ts-mockito';",
      "",
      "describe('Test', () => {",
      "const context: IContext = { correlationId: 'test' };",
      "",
      "  // references",
      "  let sut: ServiceUnderTest;",
      "  let module: TestingModule;",
      "  let connection: Connection;",
      "  let model: Model<MongoDocument>;",
      "  let server: MongoMemoryServer;",
      "  // mocks",
      "  let someOtherServiceMock: SomeOtherService;",
      "",
      "  beforeAll(async () => {",
      "    someOtherServiceMock = mock(SomeOtherService);",
      "    module = await Test.createTestingModule({",
      "      imports: [",
      "        MongooseModule.forRootAsync({",
      "          useFactory: async () => {",
      "            server = await MongoMemoryServer.create();",
      "            return {",
      "              uri: server.getUri(),",
      "            };",
      "          },",
      "        }),",
      "        MongooseModule.forFeature([{ name: MongoEntity.name, schema: MongoSchema }]),",
      "      ],",
      "      providers: [",
      "        ServiceUnderTest,",
      "        {",
      "          provide: LoggerService,",
      "          useValue: mock(LoggerService),",
      "        },",
      "        {",
      "          provide: SomeOtherService,",
      "          useValue: instance(someOtherServiceMock),",
      "        },",
      "      ],",
      "    }).compile();",
      "",
      "    model = module.get(getModelToken(MongoEntity.name));",
      "    connection = await module.get(getConnectionToken());",
      "    sut = module.get(ServiceUnderTest);",
      "  });",
      "",
      "  beforeEach(async () => {",
      "    await model.deleteMany({});",
      "    reset(someOtherServiceMock);",
      "  });",
      "",
      "  afterAll(async () => {",
      "    if (server) {",
      "      await server.stop();",
      "    }",
      "    if (connection) {",
      "      await connection.close(true);",
      "    }",
      "    if (module) {",
      "      await module.close();",
      "    }",
      "  });",
      "",
      "  describe('', () => {",
      "    it('should ', async () => {",
      "    await sut.someMethod();",
      "    });",
      "  });",
      "});"
    ]
  },
  "unit-test": {
    "prefix": "ss-unit-integration",
    "body": [
      "import { IContext, LoggerService } from '@flip/intelligence';",
      "import { Test, TestingModule } from '@nestjs/testing';",
      "import { instance, mock, reset } from 'ts-mockito';",
      "",
      "describe('Test', () => {",
      "const context: IContext = { correlationId: 'test' };",
      "",
      "  // references",
      "  let sut: ServiceUnderTest;",
      "  let module: TestingModule;",
      "  // mocks",
      "  let someOtherServiceMock: SomeOtherService;",
      "",
      "  beforeAll(async () => {",
      "    someOtherServiceMock = mock(SomeOtherService);",
      "    module = await Test.createTestingModule({",
      "      providers: [",
      "        ServiceUnderTest,",
      "        {",
      "          provide: LoggerService,",
      "          useValue: mock(LoggerService),",
      "        },",
      "        {",
      "          provide: SomeOtherService,",
      "          useValue: instance(someOtherServiceMock),",
      "        },",
      "      ],",
      "    }).compile();",
      "",
      "    sut = module.get(ServiceUnderTest);",
      "  });",
      "",
      "  beforeEach(async () => {",
      "    reset(someOtherServiceMock);",
      "  });",
      "",
      "  afterAll(async () => {",
      "    if (module) {",
      "      await module.close();",
      "    }",
      "  });",
      "",
      "  describe('', () => {",
      "    it('should ', async () => {",
      "    await sut.someMethod();",
      "    });",
      "  });",
      "});"
    ]
  },
  "object-id": {
    "prefix": "ss-import-mongodb-object-id",
    "body": [
      "import { ObjectId } from 'mongodb';"
    ],
  },
  "error-logger": {
    "prefix": "ss-error-logger",
    "body": [
      "this.logger.error(`Failed to $1 - ${error?.message}`, error?.stack as string, { ...context });"
    ]
  },
  "inject-logger": {
    "prefix": "ss-logger",
    "body": [
      "private readonly logger: LoggerService,"
    ]
  },
  "mongo-migration": {
    "prefix": "ss-migration",
    "description": "Template for MongoDB migration using Mongoose",
    "body": [
      "/* eslint-disable @typescript-eslint/no-empty-function */",
      "/* eslint-disable @typescript-eslint/no-var-requires */",
      "const mongoose = require('mongoose');",
      "const { COLLECTION_NAME, Schema } = require('path/to/schema');",
      "",
      "mongoose.model(MODEL_NAME, Schema, COLLECTION_NAME);",
      "",
      "async function up() {",
      "  const model = this(MODEL_NAME, COLLECTION_NAME);",
      "  let operations = [];",
      "  let batchSize = 200;",
      "",
      "  const cursor = await model.find(",
      "      {},",
      "      {",
      "        _id: 1,",
      "      },",
      "    )",
      "    .lean()",
      "    .cursor();",
      "",
      "  for (let doc = await cursor.next(); !!doc; doc = await cursor.next()) {",
      "    operations.push({",
      "      updateOne: {",
      "        filter: { _id: doc._id },",
      "        update: {",
      "          set: {",
      "            fieldName: 'fieldValue',",
      "          },",
      "        },",
      "      },",
      "    });",
      "",
      "    if (operations.length > batchSize) {",
      "      await model.collection.bulkWrite(operations);",
      "      operations = [];",
      "    }",
      "  }",
      "",
      "  if (operations.length) {",
      "    await model.collection.bulkWrite(operations);",
      "    operations = [];",
      "  }",
      "}",
      "",
      "async function down() {}",
      "",
      "module.exports = { up, down };"
    ]
  },
  "mongo-index-set-migration": {
    "prefix": "ss-migration-index",
    "body": [
      "/* eslint-disable @typescript-eslint/no-empty-function */",
      "/* eslint-disable @typescript-eslint/no-var-requires */",
      "const mongoose = require('mongoose');",
      "",
      "// data",
      "const indexName = 'name_1'",
      "const indexSet = { name: 1 };",
      "const modelName = entity.name;",
      "const collectionName = COLLECTION_NAME;",
      "const schema = NameSchema;",
      "",
      "// generic",
      "mongoose.model(modelName, schema, collectionName);",
      "",
      "async function up() {",
      "  await this(modelName, collectionName).collection.createIndex(indexSet, {",
      "    background: true,",
      "    name: indexName,",
      "  });",
      "}",
      "",
      "async function down() {",
      "  await this(modelName, collectionName).collection.dropIndex(indexName);",
      "}",
      "",
      "module.exports = { up, down };"
    ]
  }
}